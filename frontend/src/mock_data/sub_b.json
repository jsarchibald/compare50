{
    "id": 2,
    "files": [
        {
            "id": 3,
            "name": "dictionary.h",
            "language": "C",
            "content": "// Declares a dictionary's functionality\n\n#ifndef DICTIONARY_H\n#define DICTIONARY_H\n\n#include <stdbool.h>\n\n// Maximum length for a word\n// (e.g., pneumonoultramicroscopicsilicovolcanoconiosis)\n#define LENGTH 45\n\n// Prototypes\nbool check(const char *word);\nbool load(const char *dictionary);\nunsigned int size(void);\nbool unload(void);\n\n#endif // DICTIONARY_H\n"
        },
        {
            "id": 4,
            "name": "dictionary.c",
            "language": "C",
            "content": "// Implements a dictionary's functionality\n#include <stdbool.h>\n#include <cs50.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <strings.h>\n#include <ctype.h>\n\n#include \"dictionary.h\"\n\n#define HASHSIZE 150000\n\n// define struct for word and node pair\ntypedef struct node\n{\n    char word[LENGTH + 1];\n    struct node *next;\n}\nnode;\n\n// create hashtable array of lists and set to null at first (also head)\nnode *hashtable[HASHSIZE] = {NULL};\n\n// this doesn't work, need initializer\n//hashtable = NULL;\n\n// word/dict count tracker\nint dictCount = 0;\n\n// djb2 hash - http://www.cse.yorku.ca/~oz/hash.html\nunsigned long hash(const char *str)\n{\n    unsigned long hash = 5381;\n    int c;\n\n    while ((c = *str++))\n    {\n        hash = ((hash << 5) + hash) + c;\n    }\n    return hash;\n}\n\n// Returns true if word is in dictionary else false\nbool check(const char *word)\n{\n    char inputWord[LENGTH + 1];\n    int wordLen = strlen(word);\n\n    // convert input word to all lowercase for case insensitivty\n    for (int i = 0; i < wordLen; i++)\n    {\n        inputWord[i] = tolower(word[i]);\n        // adds null term to end of inputword elements (45 + 1sub)\n        inputWord[wordLen] = '\\0';\n    }\n\n    // generate index from hash\n    int indexValue = hash(inputWord) % HASHSIZE;\n\n    // create cursor ptr node to head node in list\n    node *cursor = hashtable[indexValue];\n\n    // traversal loop - when cursor has not reached end of list continue\n    while (cursor != NULL)\n    {\n        // compare word entered to dict words, if word found return true\n        if (strcasecmp(cursor->word, inputWord) == 0 )\n        {\n            return true;\n        }\n        // update cursor value to next node for traversing\n        cursor = cursor->next;\n    }\n    return false;\n}\n\n// Loads dictionary into memory, returning true if successful else false\nbool load(const char *dictionary)\n{\n    char word[LENGTH + 1];\n    int indexValue;\n\n    FILE *dict = fopen(dictionary, \"r\");\n    if (dict == NULL)\n    {\n        fprintf(stderr, \"File does not exist\\n\");\n        return false;\n    }\n\n    // scan dictionary words,\n    while (fscanf(dict, \"%s\", word) != EOF)\n    {\n        // generate indexes from hash of dictwords\n        indexValue = hash(word) % HASHSIZE;\n\n        // creates dynamic temp nodes to store value of dict words\n        node *dictwordTemp = malloc(sizeof(node));\n\n        // checks to see if temp node is null, if failed unload memory\n        if (dictwordTemp == NULL)\n        {\n            unload();\n            return false;\n        }\n\n        // else, put word from temp nodes into word\n        strcpy(dictwordTemp->word, word);\n\n        // increment dictionary word count\n        dictCount++;\n\n        // check if list at index is empty, if so insert\n        if (hashtable[indexValue] == NULL)\n        {\n            // update the end portion of node to be the last node\n            dictwordTemp->next = NULL;\n            // update head node link to current value/data node for list\n            hashtable[indexValue] = dictwordTemp;\n        }\n\n        // if list isn't empty at the index, insert/append elsewhere\n        else\n        {\n            // set node to value of index\n            dictwordTemp->next = hashtable[indexValue];\n            hashtable[indexValue] = dictwordTemp;\n        }\n    }\n    fclose(dict);\n    return true;\n}\n\n// Returns number of words in dictionary if loaded else 0 if not yet loaded\nunsigned int size(void)\n{\n    if (dictCount > 0)\n    {\n        return dictCount;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n// Unloads dictionary from memory, returning true if successful else false\nbool unload(void)\n{\n    // iterate through all elements in hashtable\n    for (int i = 0; i < HASHSIZE; i++)\n    {\n        // set cursor ptr to beginning/head of hashtable\n        node *cursor = hashtable[i];\n\n        // while cursor has not reached end continue loop\n        while (cursor != NULL)\n        {\n            node *temp = cursor;\n            // set cursor to continue\n            cursor = cursor->next;\n            free(temp);\n        }\n    }\n    return true;\n}"
        }
    ]
}
